接口型模式：适配器模式、外观模式、合成模式、桥接模式
职责型模式：单例模式、调停者模式、代理模式、职责链模式、享元模式
构造型模式：构建者模式、工厂方法模式、抽象工厂模式、原型模式、备忘录模式
操作型模式：模板方法模式、状态模式、策略模式、命令模式、解释器模式
扩展型模式：装饰器模式、迭代器模式、访问者模式

工厂方法模式：定义一个用于创建对象的接口，并控制返回哪个类的实例。让服务的提供者确定实例化哪个类，而不是客户代码

识别工厂方法：工厂方法模式通常包含了若干类，这些类实现了相同的操作，返回了相同的抽象类型，然而这些操作
的内部，实际上却实例化了不同的类，并且这些类都实现了上述抽象类型。当客户代码请求一个新对象时，这个新对象
该由哪个类实例化，取决于工厂对象接收创建请求时的行为。

控制要实例化的类：把创建对象的工作转交给一个借口，来完成实例化的控制。一种解决方案是让两个类同时实现一个
标准接口，并创建一个工厂方法来返回该接口的某个实例。

并行层次结构中的工厂方法模式：可以避免类的规模过于庞大。工厂方法模式可以根据一个类层次中的子类，确定
另一个相关层次中哪一个类被实例化，从而建立对应的并行层次结构。

抽象工厂模式：又名工具箱，其意图是允许创建一组相关或相互依赖的对象。

代理模式：通过一个代理(Proxy)或者占位符来控制对该对象的访问。
代理对象通常拥有一个几乎和实际对象相同的接口。它常常会控制访问，并将请求合理地转发给底层的真实对象。

代理模式的实现为对象建立了一个占位符，用来管理对目标对象的访问。代理对象可以隔离目标对象的状态迁移，
例如图片加载的时间变化。然而，运用代理模式会使得代理对象与被代理对象造成紧耦合。Java中的动态代理提供
了一种增加可复用功能的机制。倘若某个对象实现了你想要拦截的借口方法，就可以使用动态代理去包装这个对象，
增加自己的逻辑或者替换被包装对象的代码。

单例模式：确保一个类有且仅有一个实例，并为它提供一个全局访问点。
单例和线程：建议使用属于当前类的锁进行同步。(Object classLock=Factory.class
						synchronized(classLock){
							……
						})
单例模式常常会引入一些耦合。应该减少运用单例模式的类的数量：最好的方式是，类只需知道与它协作的对象，
却不必了解创建它所需要的限制。

策略模式：将可互换的方法封装在各自独立的类中，并且让每个方法都实现一个公共的操作。


 
test


